from XTSApp.models import SharedObject
from utils.server_request import service
from dotenv import load_dotenv
import os
import sys
from tenacity import retry, stop_after_attempt, wait_fixed

sys.path.append(f"{os.path.abspath('./')}")

load_dotenv()


def create_logs(logger, process_id, message, type='info'):
    if type == 'error':
        logger.error(message)
        SharedObject.modify_value(
            f'Error: {message}', process_id, nested_key='logs')
    else:
        logger.info(message)
        SharedObject.modify_value(
            f'Info: {message}', process_id, nested_key='logs')

def check_finished(logs:list, side=None)->str:
    '''
    Cheking the value is already square off or not
    logs: Log generated by orders
    '''
    for log in logs:
        log_trace = log.upper()
        if 'FININSHED' in log.upper():
            return True
        if side and 'STOPLOSS HIT {side}:' in log_trace:
            return True
    return False

class Data:
    def __init__(self):
        self.exchange_instrument_id = ''

    @staticmethod
    def get_ltp(exchange_instrument_id: int):
        data = service.get_data(exchange_instrument_id)
        # print(f'ltp_data {data}')
        return data

    @staticmethod
    def get_bid(bid):
        pass

# index: ["BANKNIFTY", "NIFTY"]
def get_atm(xt, index: str, atm_strike) -> list[str]:
    data = {}
    for gap in range(-200, 300, 100):
        atm_strike_tmp = atm_strike + gap
        exchange_instrument_id_ce = get_exchange_instrument_id(
            xt, index, atm_strike_tmp, "CE", "22May2024"
        )
        exchange_instrument_id_pe = get_exchange_instrument_id(
            xt, index, atm_strike_tmp, "PE", "22May2024"
        )
        ce_rate = Data.get_ltp(exchange_instrument_id_ce)
        pe_rate = Data.get_ltp(exchange_instrument_id_pe)
        # print(f'Rates in the market, {ce_rate}, {pe_rate}, {exchange_instrument_id_ce}')
        data[abs(ce_rate - pe_rate)] = [
            exchange_instrument_id_ce,
            exchange_instrument_id_pe,
            atm_strike_tmp
        ]
    return data[min(data.keys())]


def get_otm(xt, index: str, atm_strike, otm_gap, side) -> list[str]:
    '''
    getting otm values based on strategy

    '''
    otm_gap = otm_gap*100
    atm_strike = {
        'CE': atm_strike + otm_gap,
        'PE': atm_strike - otm_gap
    }
    exchange_instrument_id = get_exchange_instrument_id(
        xt, index, atm_strike[side], side, "22May2024"
    )
    _rate = Data.get_ltp(exchange_instrument_id)

    return [exchange_instrument_id, atm_strike[side]]


# def get_exchange_instrument_id(xt, index, strike, side, expiry):
#     exchange_segment = 2
#     _series = "OPTIDX"
#     if index in ["SENSEX", "BANKEX"]:
#         exchange_segment = 12
#         _series = "IO"
#     # print(exchange_segment, _series, index, side, strike, expiry)
#     response = xt.get_option_symbol(
#         exchangeSegment=exchange_segment,
#         series=_series,
#         symbol=index,
#         optionType=side,
#         strikePrice=strike,
#         expiryDate=expiry,
#     )
#     # print(f'get_exchange_instrument_id --> {response}')
#     data = response["result"][0]
#     exchange_instrument_id = data["ExchangeInstrumentID"]
#     instrument = data["Description"]
#     return exchange_instrument_id

@retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
def get_exchange_instrument_id(xt, index, strike, side, expiry):
    exchange_segment = 2
    _series = "OPTIDX"
    if index in ["SENSEX", "BANKEX"]:
        exchange_segment = 12
        _series = "IO"
    response = xt.get_option_symbol(
        exchangeSegment=exchange_segment,
        series=_series,
        symbol=index,
        optionType=side,
        strikePrice=strike,
        expiryDate=expiry,
    )
    data = response["result"][0]
    exchange_instrument_id = data["ExchangeInstrumentID"]
    instrument = data["Description"]
    return exchange_instrument_id


@retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
def get_trade_ltp(xt, order_id):
    response = xt.get_trade(clientID="DELOPT")
    print(f'ltp response -------------------------------------------> {response}')
    if 'result' not in response.keys():
        raise KeyError("Result key not found in response")
    for trade in response["result"]:
        if trade["AppOrderID"] == order_id:
            return trade["LastTradedPrice"]
    raise KeyError("Order ID not found in response")


# if __name__ == "__main__":
#     xt = UpdatedXTSConnect(
#         os.getenv("INTERACTIVE_KEY"), os.getenv("INTERACTIVE_SECRET"), "WEBAPI"
#     )
#     xt.marketdata_login(token=os.getenv("TOKEN"), userId=os.getenv("USERID"))
#     print(get_trade_ltp(xt, 1200025035))
